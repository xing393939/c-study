### Linux系统编程

#### 第 28 章 文件与I/O
1. C标准I/O库函数
  * fopen(3) 调用open(2)打开指定的文件，返回一个文件描述符
  * fgetc(3) I/O缓冲区中能否读到，不能就调用read(2)让内核读取该文件的数据到I/O缓冲区，再读
  * fputc(3) 判断I/O缓冲区是否有空间存，不能就调用write(2)，让内核把I/O缓冲区的内容写回文件
  * fclose(3) 如果I/O缓冲区中还有数据没写回文件，就调用write(2)写回文件，然后调用close(2)关闭文件
1. open、read、write、close等系统函数称为无缓冲I/O函数。写程序应该用标准I/O库函数：
  * 调一个系统调用比调一个用户空间的函数要慢很多
  * 用C标准I/O库函数要时刻注意I/O缓冲区和实际文件有可能不一致，需要管理
  * 网络编程通常直接调用无缓冲I/O函数
1. 所有支持C语言的平台上应该都可以用C标准库函数，标准I/O库函数在头文件stdio.h中声明。系统函数如下：
  * UNIX平台，无缓存I/O函数在头文件unistd.h中声明
  * Windows系统，底层是Win32 API，其中读写文件的系统函数是ReadFile、WriteFile
1. 由open返回的文件描述符一定是该进程尚未使用的最小描述符。程序启动时自动打开文件描述符0、1、2对应stdin、stdout、stderr
1. 进程的三个状态：
  * 执行：CPU在执行，程序计数器里保存着该进程的指令地址，通用寄存器里保存着该进程运算过程的中间结果
  * 就绪：不需要等待什么事件发生，随时都可以执行，但CPU暂时还在执行另一个进程。内核的调度算法是基于优先级和时间片的
  * 阻塞：导致进程阻塞的典型事件有：请求I/O，申请缓冲空间等
1. command > /dev/null 2>&1 #2表示stderr，&1表示stdout的地址
1. ioctl用于向设备发控制和配置命令，如串口的波特率、校验位、停止位
1. 把磁盘文件的一部分直接映射到内存：
  * void *mmap(void *addr, size_t len, int prot, int flag, int filedes, off_t off); #对文件的读写可以直接用指针
  * int munmap(void *addr, size_t len); #解除内存映射

#### 第 29 章 文件系统
1. ext2文件系统分为Boot Block和Block Group。Boot Block只有1KB，用来存储磁盘分区信息和启动信息，任何文件系统都不能使用启动块。
1. Block Groups
  * Super Block，存块大小、文件系统版本号、上次mount的时间等等
  * Group Descriptor Table（GDT），有多少个块组就对应有多少个块组描述符。存从哪里开始是inode表，从哪里开始是数据块，空闲的inode和数据块还有多少个等等。
  * 块位图（Block Bitmap）
  * inode位图（inode Bitmap）
  * inode表（inode Table），存inode信息，例如文件类型（常规、目录、符号链接等）
  * 数据块（Data Block）
    1. 对于常规文件，文件的数据存储在数据块中。
    1. 对于目录，该目录下的所有文件名和目录名存储在数据块中
    1. 对于符号链接，目标路径名短就存inode，长就存数据块
    1. 设备的主设备号和次设备号保存在inode中。
  * 数据块（Data Block）
    1. 索引项一共有15个，0~11是直接寻址，12是一级间接寻址，13是二级间接寻址，14是三级间接寻址。
    1. 假设块大小是1KB，一个索引项占4byte
    1. 0~11能存12KB
    1. 12能存1024 / 4 = 256KB
    1. 13能存(1024 / 4)*(1024 / 4) = 64MB
    1. 14能存(1024 / 4)\*(1024 / 4)\*(1024 / 4) = 16GB
1. 虚拟文件系统（VFS，Virtual Filesystem）即文件系统抽象层，使得文件、目录、读写访问等概念成为抽象层的概念，因此各种文件系统(ext2、ext3)用起来都一样














