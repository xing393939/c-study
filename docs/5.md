### Linux系统编程

#### 第 28 章 文件与I/O
1. C标准I/O库函数
  * fopen(3) 调用open(2)打开指定的文件，返回一个文件描述符
  * fgetc(3) I/O缓冲区中能否读到，不能就调用read(2)让内核读取该文件的数据到I/O缓冲区，再读
  * fputc(3) 判断I/O缓冲区是否有空间存，不能就调用write(2)，让内核把I/O缓冲区的内容写回文件
  * fclose(3) 如果I/O缓冲区中还有数据没写回文件，就调用write(2)写回文件，然后调用close(2)关闭文件
1. open、read、write、close等系统函数称为无缓冲I/O函数。写程序应该用标准I/O库函数：
  * 调一个系统调用比调一个用户空间的函数要慢很多
  * 用C标准I/O库函数要时刻注意I/O缓冲区和实际文件有可能不一致，需要管理
  * 网络编程通常直接调用无缓冲I/O函数
1. 所有支持C语言的平台上应该都可以用C标准库函数，标准I/O库函数在头文件stdio.h中声明。系统函数如下：
  * UNIX平台，无缓存I/O函数在头文件unistd.h中声明
  * Windows系统，底层是Win32 API，其中读写文件的系统函数是ReadFile、WriteFile
1. 由open返回的文件描述符一定是该进程尚未使用的最小描述符。程序启动时自动打开文件描述符0、1、2对应stdin、stdout、stderr
1. 进程的三个状态：
  * 执行：CPU在执行，程序计数器里保存着该进程的指令地址，通用寄存器里保存着该进程运算过程的中间结果
  * 就绪：不需要等待什么事件发生，随时都可以执行，但CPU暂时还在执行另一个进程。内核的调度算法是基于优先级和时间片的
  * 阻塞：导致进程阻塞的典型事件有：请求I/O，申请缓冲空间等
1. command > /dev/null 2>&1 #2表示stderr，&1表示stdout的地址
1. ioctl用于向设备发控制和配置命令，如串口的波特率、校验位、停止位
1. 把磁盘文件的一部分直接映射到内存：
  * void *mmap(void *addr, size_t len, int prot, int flag, int filedes, off_t off); #对文件的读写可以直接用指针
  * int munmap(void *addr, size_t len); #解除内存映射

#### 第 29 章 文件系统
1. ext2文件系统分为Boot Block和Block Group。Boot Block只有1KB，用来存储磁盘分区信息和启动信息，任何文件系统都不能使用启动块。
1. Block Groups
  * Super Block，存块大小、文件系统版本号、上次mount的时间等等
  * Group Descriptor Table（GDT），有多少个块组就对应有多少个块组描述符。存从哪里开始是inode表，从哪里开始是数据块，空闲的inode和数据块还有多少个等等。
  * 块位图（Block Bitmap）
  * inode位图（inode Bitmap）
  * inode表（inode Table），存inode信息，例如文件类型（常规、目录、符号链接等）
  * 数据块（Data Block）
    1. 对于常规文件，文件的数据存储在数据块中。
    1. 对于目录，该目录下的所有文件名和目录名存储在数据块中
    1. 对于符号链接，目标路径名短就存inode，长就存数据块
    1. 设备的主设备号和次设备号保存在inode中。
  * 数据块（Data Block）
    1. 索引项一共有15个，0~11是直接寻址，12是一级间接寻址，13是二级间接寻址，14是三级间接寻址。
    1. 假设块大小是1KB，一个索引项占4byte
    1. 0~11能存12KB
    1. 12能存1024 / 4 = 256KB
    1. 13能存(1024 / 4)*(1024 / 4) = 64MB
    1. 14能存(1024 / 4)\*(1024 / 4)\*(1024 / 4) = 16GB
1. 虚拟文件系统（VFS，Virtual Filesystem）即文件系统抽象层，使得文件、目录、读写访问等概念成为抽象层的概念，因此各种文件系统(ext2、ext3)用起来都一样

#### 第 30 章 进程	
1. 每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，是一个task_struct结构体
1. 内核函数pid_t fork(void); 调用一次，父进程接收到的pid_d=子进程id；子进程接收到的pid_t=0
  * 子进程调用getpid函数得到自己的进程id，也可以调用getppid函数得到父进程的id
  * 父进程只能在fork的时候接收pid_d记录子进程的id
  * 父、子进程中相同编号的文件描述符在内核中指向同一个file结构体，也就是说，file结构体的引用计数要增加。
1. 如果一个进程已经终止，但是它的父进程尚未调用wait或waitpid对它进行清理，这时的进程状态称为僵尸进程
  * 父进程调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程
1. 进程间通信（IPC）：进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区交换数据
  * 管道int pipe(int filedes[2]); 成功返回0，失败返回-1。四种特殊情况：
    1. 写端关闭了，读端读到最后一个字节是0
    1. 写端没有关闭，读端读到没有数据再次读会阻塞
    1. 读端关闭了，写端写数据会收到信号SIGPIPE，导致异常退出
    1. 读端没有关闭，写端写满了后再次写会阻塞
  * 父进程通过fork可以将打开文件的描述符传递给子进程
  * 子进程结束时，父进程调用wait可以得到子进程的终止信息
  * 几个进程可以在文件系统中读写某个共享文件，也可以通过给文件加锁来实现进程间同步
  * 进程之间互发信号，一般使用SIGUSR1和SIGUSR2实现用户自定义功能
  * FIFO有名管道
  * mmap函数，几个进程可以映射同一内存区
  * System V IPC: 包括消息队列、信号量和共享内存
  * UNIX Domain Socket，目前最广泛使用的IPC机制
1. FIFO和UNIX Domain Socket都是利用文件系统中的特殊文件来标识的，linux下文件类型的首字母含义：
  * -rw-r—r—，-开头的都是普通文件；
  * drw-r—r—，d开头的是目录文件；
  * brw-r—r—，b开头的文件都是块设备文件，如硬盘；
  * crw-r—r—，c开头的文件都是字符设备文件，如串口和键盘；
  * srw-r—r—，s开头的文件都是socket文件，如mysql.sock；
  * prw-r—r—，p开头的文件都是有名管道文件；
  * lrw-r—r—，l开头的文件都是软链接文件；





























