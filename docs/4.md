### C语言本质

#### 第 14 章 计算机中数的表示
1. 全加器电路：A+B=S，Cin是低位传上来的进位，Cout是产生的进位
1. 1的补码：A-B=A+B的补码，计算结果的最高位如果有进位则要加回到最低位上去
  * 例：00001000-00000100 → 00001000+(-00000100) → 00001000+11111011 → 00000011进1 → 高位进的1加到低位上去，结果为00000100
  * 八位运算中，最高位0表示正数，1表示负数。正数是从00000000到01111111（0~127），负数的取值范围是从10000000到11111111（-127~0）
1. 2的补码，在1的补码的基础上，规定了11111111表示-128，八位运算的范围即是：-128~127
1. 浮点数的表示方法：14位，最高位是符号位，接着5位是表示指数，最后8位表示尾数（最高位的1默认被舍弃）
1. 17=(0.10001)×2^5的正规化尾数浮点数为：0 10101 00010000
  * 0为符号位
  * 10101表示21，21-16=5
  * 00010000最前面再加一个1，即为0.10001

#### 第 15 章 数据类型详解
1. unsigned char型表示无符号数，signed char型表示有符号数。ASCII码的取值范围是0~127，所以都没有问题。
1. 八进制整数常量以0开头，十进制的整数常量不能以0开头，十六进制整数常量以0x或0X开头
1. 整数常量末尾加u或U表示“unsigned”，加l或L表示“long”，加ll或LL表示“long long”
1. 大部分平台的浮点数实现遵循IEEE 754，float型通常是32位，double型通常是64位。
1. 没有后缀的浮点数常量是double型的，有后缀f或F的浮点数常量是float型的，有后缀l或L的浮点数常量是long double型的。
1. 由赋值产生的类型转换（隐式类型转换）：
  * 例如int c = 3.14;，编译器会把右边的double型转成int型再赋给变量c
  * 例如int foo(int, int);，则调用foo(3.1, 4.2)时会自动把两个double型的实参转成int型赋给形参，返回值1.2会自动转成int型再返回。
1. 强制类型转换：例如计算表达式(double)3 + i，首先将整数3强制转换成double型（值为3.0），然后和整型变量i相加

#### 第 16 章 运算符详解
1. 在一定的取值范围内，将一个整数左移1位相当于乘以2；将一个整数右移1位相当于除以2。
1. 建议只对无符号数做位运算，以减少出错的可能。
1. 位与&：0011 & 0101 = 0001
1. 位或|：0011 | 0101 = 0111
1. 异或^：0011 ^ 0101 = 0110 一个数和自己做异或的结果是0。
1. 取反~: ~1100 = 0011
1. 左移<< 
1. 右移>>
1. 例如a[foo()] += 1和a[foo()] = a[foo()] + 1，如果foo()会打印消息，那么前者只打印一次，而后者打印两次。
1. 逗号运算符：表达式1, 表达式2, 表达式3, ...。表达式1先求值，求完了直接把值丢掉，再求表达式2的值作为整个表达式的值。
1. sizeof运算符的结果是size_t类型的，这个类型定义在stddef.h头文件中。
1. C标准规定size_t是一种无符号整型
1. 原则一：在两个Sequence Point之间，同一个变量的值只允许被改变一次。
  * 反例：a = (++a)+(++a)+(++a)+(++a); 五个Side Effect都在改变a的值
1. 原则二：如果在两个Sequence Point之间既要读一个变量的值又要改它的值，只有在读写顺序确定的情况下才可以这么写。
  * 反例：a[i++] = i; 因为等号左边改i的值，等号右边读i的值，到底是先改还是先读？这个读写顺序是不确定的。
1. 运算符，优先级从高到低：
  * ()括号
  * 后缀运算符：数组取下标[]、函数调用()、结构体取成员“.”、指针取成员->、后缀自增++、后缀自减--
  * 前缀运算符：前缀自增++、前缀自减--、sizeof、类型转换()、取地址运算&、指针间接寻址*、正号+、负号-、按位取反~、逻辑非!
  * 乘*、除/、模%
  * 加+、减-
  * 移位运算符<<和>>
  * 关系运算符< > <= >=
  * 相等性运算符==和!=
  * 位与&、位或|、异或^、取反~
  * 逻辑与&&、逻辑或||
  










