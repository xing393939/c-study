### C语言本质

#### 第 14 章 计算机中数的表示
1. 全加器电路：A+B=S，Cin是低位传上来的进位，Cout是产生的进位
1. 1的补码：A-B=A+B的补码，计算结果的最高位如果有进位则要加回到最低位上去
  * 例：00001000-00000100 → 00001000+(-00000100) → 00001000+11111011 → 00000011进1 → 高位进的1加到低位上去，结果为00000100
  * 八位运算中，最高位0表示正数，1表示负数。正数是从00000000到01111111（0~127），负数的取值范围是从10000000到11111111（-127~0）
1. 2的补码，在1的补码的基础上，规定了11111111表示-128，八位运算的范围即是：-128~127
1. 浮点数的表示方法：14位，最高位是符号位，接着5位是表示指数，最后8位表示尾数（最高位的1默认被舍弃）
1. 17=(0.10001)×2^5的正规化尾数浮点数为：0 10101 00010000
  * 0为符号位
  * 10101表示21，21-16=5
  * 00010000最前面再加一个1，即为0.10001

#### 第 15 章 数据类型详解
1. unsigned char型表示无符号数，signed char型表示有符号数。ASCII码的取值范围是0~127，所以都没有问题。
1. 八进制整数常量以0开头，十进制的整数常量不能以0开头，十六进制整数常量以0x或0X开头
1. 整数常量末尾加u或U表示“unsigned”，加l或L表示“long”，加ll或LL表示“long long”
1. 大部分平台的浮点数实现遵循IEEE 754，float型通常是32位，double型通常是64位。
1. 没有后缀的浮点数常量是double型的，有后缀f或F的浮点数常量是float型的，有后缀l或L的浮点数常量是long double型的。
1. 由赋值产生的类型转换（隐式类型转换）：
  * 例如int c = 3.14;，编译器会把右边的double型转成int型再赋给变量c
  * 例如int foo(int, int);，则调用foo(3.1, 4.2)时会自动把两个double型的实参转成int型赋给形参，返回值1.2会自动转成int型再返回。
1. 强制类型转换：例如计算表达式(double)3 + i，首先将整数3强制转换成double型（值为3.0），然后和整型变量i相加

#### 第 16 章 运算符详解
1. 在一定的取值范围内，将一个整数左移1位相当于乘以2；将一个整数右移1位相当于除以2。
1. 建议只对无符号数做位运算，以减少出错的可能。
1. 位与&：0011 & 0101 = 0001
1. 位或|：0011 | 0101 = 0111
1. 异或^：0011 ^ 0101 = 0110 一个数和自己做异或的结果是0。
1. 取反~: ~1100 = 0011
1. 左移<< 
1. 右移>>
1. 例如a[foo()] += 1和a[foo()] = a[foo()] + 1，如果foo()会打印消息，那么前者只打印一次，而后者打印两次。
1. 逗号运算符：表达式1, 表达式2, 表达式3, ...。表达式1先求值，求完了直接把值丢掉，再求表达式2的值作为整个表达式的值。
1. sizeof运算符的结果是size_t类型的，这个类型定义在stddef.h头文件中。
1. C标准规定size_t是一种无符号整型
1. 原则一：在两个Sequence Point之间，同一个变量的值只允许被改变一次。
  * 反例：a = (++a)+(++a)+(++a)+(++a); 五个Side Effect都在改变a的值
1. 原则二：如果在两个Sequence Point之间既要读一个变量的值又要改它的值，只有在读写顺序确定的情况下才可以这么写。
  * 反例：a[i++] = i; 因为等号左边改i的值，等号右边读i的值，到底是先改还是先读？这个读写顺序是不确定的。
1. 运算符，优先级从高到低：
  * ()括号
  * 后缀运算符：数组取下标[]、函数调用()、结构体取成员“.”、指针取成员->、后缀自增++、后缀自减--
  * 前缀运算符：前缀自增++、前缀自减--、sizeof、类型转换()、取地址运算&、指针间接寻址*、正号+、负号-、按位取反~、逻辑非!
  * 乘*、除/、模%
  * 加+、减-
  * 移位运算符<<和>>
  * 关系运算符< > <= >=
  * 相等性运算符==和!=
  * 位与&、位或|、异或^、取反~
  * 逻辑与&&、逻辑或||
  
#### 第 17 章 计算机体系结构基础
1. CPU和内存是计算机的两个主要组成部分。内存中保存着数据和指令，CPU从内存中取指令执行。
  * 其中有些指令让CPU做运算
  * 有些指令让CPU读写内存中的数据
1. CPU总是周而复始地做同一件事：从内存取指令并执行。CPU最核心的功能单元包括：
  * 寄存器：像内存一样可以存取数据，但比访问内存快得多。
  * 程序计数器(PC)：是一种特殊寄存器，保存着CPU取下一条指令的地址。
  * 指令译码器：负责解释每条指令的含义，然后调动相应的执行单元去执行它。
  * 算术逻辑单元(ALU)：比如加减乘除、位运算、逻辑运算。
  * 地址和数据总线：比如从内存读一个数到寄存器，控制线发送读请求，32条地址线发送地址、32条数据线返回数据。
1. CPU的角度来看，访问设备只有内存映射I/O和端口I/O两种
  * 内存映射I/O：像内存一样访问，比如向串口write寄存器写数据，串口就发数据；向串口read寄存器读，就读到串口接受到的数据
  * 端口I/O：用一种专用的指令访问，比如in/out指令。
  * 键盘输入需要用到CPU的中断机制，CPU正在执行的指令将被打断，程序计数器会指向某个固定的地址，执行中断服务程序(ISR)
1. 现代操作系统普遍采用虚拟内存管理机制，这需要处理器中的内存管理单元(MMU)支持
1. 操作系统和MMU是这样配合的：
  * 操作系统在初始化时会执行一些指令在物理内存中填写页表，然后用指令设置MMU，告诉MMU页表在物理内存中的什么位置。 
  * 设置好之后，CPU每次执行访问内存的指令都会自动引发MMU做查表和地址转换操作
  * MMU除了做地址转换之外，还提供内存保护机制：页面分为用户模式和特权模式，访问权限又分为可读、可写和可执行三种。
1. CPU一般在用户模式执行用户程序，在中断或异常情况下CPU切换到特权模式执行内核程序，处理完中断或异常之后再返回用户模式继续执行用户程序。

#### 第 18 章 x86汇编程序基础	
1. x86的通用寄存器有eax、ebx、ecx、edx、edi、esi。大部分情况随意用。
1. 除法指令idivl要求被除数在eax寄存器中，edx寄存器必须是0，而除数可以在任意寄存器中。计算结果商数保存在eax寄存器中，余数保存在edx寄存器中。
1. 特殊寄存器：
  * eip是程序计数器
  * eflags保存着计算过程中产生的标志位：进位标志、溢出标志、零标志和负数标志分别称为CF、OF、ZF、SF
  * ebp和esp用于维护函数调用的栈帧
1. 寻址方式：
  * 直接寻址（Direct Addressing Mode）：例如movl ADDRESS, %eax把ADDRESS地址处的32位数传送到eax寄存器。
  * 变址寻址（Indexed Addressing Mode）：例如movl data_items(,%edi,4), %eax，其中4表示每个元素4个字节，访问地址是data_items + edi * 4
  * 间接寻址（Indirect Addressing Mode）：例如movl (%eax), %ebx，把eax寄存器的值看作地址
  * 基址寻址（Base Pointer Addressing Mode）：例如movl 4(%eax), %ebx，用于访问结构体成员比较方便，例如一个结构体的基地址保存在eax寄存器中，其中一个成员在结构体内的偏移量是4字节
  * 立即数寻址（Immediate Mode）：例如movl $12, %eax中的$12，这其实跟寻址没什么关系，但也算作一种寻址方式。
  * 寄存器寻址（Register Addressing Mode）：例如movl $12, %eax中的%eax。  
1. 各种UNIX系统的可执行文件都采用ELF格式，有三种类型：
  * 目标文件（Relocatable），运行as hello.s -o hello.o用汇编器生成目标文件，或者gcc -c hello.s
  * 可执行文件（Executable），运行ld hello.o -o hello用链接器生成可执行文件，或者gcc hello.o
  * 共享库（Shared Library）
  * C转汇编：gcc -S main.c
1. [ELF文件解析（一）：Segment和Section](https://www.cnblogs.com/jiqingwu/p/elf_format_research_01.html)  
1. [ELF文件解析（二）：ELF header详解](https://www.cnblogs.com/jiqingwu/p/elf_explore_2.html)
1. [ELF文件解析（三）：sections](https://www.cnblogs.com/jiqingwu/p/elf_explore_3.html)
1. ELF文件，通过readelf -W -a hello.s查看大概有4个部分：
  * ELF Header：描述了体系结构和操作系统信息
    1. ELF header在32位的机器占52个字节，在64位的机器占64个字节
    1. ELF header定义了Section Headers表和Program Headers表的偏移字节，两个表的条数，每个条目的字节大小
  * Section Headers：目标文件需要
    1. Section Headers的每个条目是一个section，32位占40字节，64位占64字节
    1. .text是代码section，Flags是AX，表示要分配内存且可执行
    1. .data和.bss的Flags的Flags都是WA，表示可写，需分配内存，这都是数据section的特征
  * Program Headers：可执行文件需要
    1. Program Headers的每个条目是一个segment，其中type=LOAD才是运行时需要的
    1. segment的LOAD=RE一般是代码段，LOAD=RW一般是数据段
    1. Program Headers的每个条目在Section to Segment mapping区域一一对应，可以找到segment包含的多个section
  * Sections：主体内容
```
data_items:
 .long 3,67,34,222,45,75,54,34,44,33,22,11,66,0
 .globl _start
_start:
 movl $0, %edi  	            # 初始化edi=0
 movl data_items(,%edi,4), %eax # 初始化eax=data_items[edi]
 movl %eax, %ebx 	            # 初始化ebx=eax

start_loop:
 cmpl $0, %eax  	            # 检查eax是否为0
 je loop_exit
 incl %edi 		                # edi++
 movl data_items(,%edi,4), %eax # eax=data_items[edi]
 cmpl %ebx, %eax 	            # eax是否<=ebx
 jle start_loop 	
 movl %eax, %ebx 	            # ebx=eax
 jmp start_loop 	            # 继续

loop_exit:
 movl $1, %eax  	            # 调用exit退出
 int $0x80                      # int为软中断指令，0x80表示系统调用
                                # 执行用户程序时CPU处于用户模式，int $0x80就是切换到CPU模式进行系统调用
                                # eax表示调那个系统调用，ebx是传参。eax=1表示终止进程，ebx的值通过echo $?打印
```

#### 第 19 章 汇编与C之间的关系
1. [寄存器理解 及 X86汇编入门](https://www.cnblogs.com/jokerjason/p/9455638.html)，描述了函数堆栈的过程图
1. 在执行程序时，操作系统为进程分配一块栈空间来保存函数栈帧。在执行foo(2, 3)时，esp寄存器总是指向栈顶，函数栈帧保存三个值：
  * esp=0xbf822d22
  * 第二个参数保存在esp+4指向的内存位置，
  * 第一个参数保存在esp指向的内存位置
  * 函数结束后下一条指令的地址，同时把esp的值减4，esp=0xbf822d18
1. 函数调用和返回过程中的规则：
  * 参数压栈传递，并且是从右向左依次压栈。
  * ebp总是指向当前栈帧的栈底。
  * 返回值通过eax寄存器传递。
























